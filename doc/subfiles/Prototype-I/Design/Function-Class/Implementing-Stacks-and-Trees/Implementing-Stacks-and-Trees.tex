\documentclass[../../../../../main.tex]{subfiles}


\begin{document}

\subsection{Designing an Implementation of Stacks and Trees}
Since stacks and trees are a prerequisite to our function class, we will design them now.\\
Our stack does not need to become infinitely big, as the size of the \texttt{Stack}, as discussed in the last section, is $m$ where $m$ is the number of operands. Therefore we can initialize an array of size $m$ and manipulate the array to make it act like a \texttt{Stack}.\\
Our binary tree will be quite simple, containing only the bare minimum of what our binary tree needs, with an added traversal function which returns the post-order depth-first traversal of the tree. For simplicity we will use a private static helper function, which will take a tree and a stack as parameter. This stack which is passed in by reference will be edited in every recursive call. We will also make our left and right tree attributes public. This is because our root tree will be public, and as the left and right sub-trees are simply different copies of the root tree, it isn't consistent to make the right and left private while keeping the root tree public.\\
\begin{figure}[h]
\centering
\begin{minipage}{.5\textwidth}
  \centering
  \includegraphics[width=.4\linewidth]{diagrams/stack.mps}
\end{minipage}%
\begin{minipage}{.5\textwidth}
  \centering
  \includegraphics[width=.8\linewidth]{diagrams/tree.mps}
\end{minipage}

\caption{Class Diagrams}
\end{figure}
\\
\begin{algorithm}
\caption{Post-Order Depth-First Traversal Helper}
\label{alg:traverseHelper}
\DontPrintSemicolon
\Fn{traverseHelper(\KwTree tree,\KwStack \&order)}{
	\eIf{tree == \KwNull}{
		\KwRet; 
	}{
		traverse(tree.left,order)\;
		traverse(root.right,order)\;
		order.add(root.data)\;
	}
}
\end{algorithm}
\begin{algorithm}
\caption{Post-Order Depth-First Traversal}
\label{alg:traverse}
\DontPrintSemicolon
\Fn{traverse()}{
	\KwStack order\;
	traverseHelper(this,order)\;
	\KwRet order\;
}
\end{algorithm}

\newpage

\end{document}